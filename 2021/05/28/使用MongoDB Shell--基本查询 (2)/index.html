<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>使用MongoDB Shell--基本查询 (2) | zl的个人博客</title><meta name="description" content="“MongoDB的标准发行版本中提供了mongo shell。它提供了一种具有对JavaScript语言和标准函数的完全访问权限的JavaScript环境。它为MongoDB数据库提供了一个完整接口。” 在本章中，将学习mongo shell的基础知识以及如何使用它来管理MongoDB文档。在你深入探究创建与数据库交互的应用程序之前，理解MongoDB shell如何工作是很重要的。 没有比上手使"><meta name="keywords" content="java 技术,各种小工具"><meta name="author" content="lilongzhe"><meta name="copyright" content="lilongzhe"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用MongoDB Shell--基本查询 (2)"><meta name="twitter:description" content="“MongoDB的标准发行版本中提供了mongo shell。它提供了一种具有对JavaScript语言和标准函数的完全访问权限的JavaScript环境。它为MongoDB数据库提供了一个完整接口。” 在本章中，将学习mongo shell的基础知识以及如何使用它来管理MongoDB文档。在你深入探究创建与数据库交互的应用程序之前，理解MongoDB shell如何工作是很重要的。 没有比上手使"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="使用MongoDB Shell--基本查询 (2)"><meta property="og:url" content="https://llz-github.github.io/2021/05/28/%E4%BD%BF%E7%94%A8MongoDB%20Shell--%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%20(2)/"><meta property="og:site_name" content="zl的个人博客"><meta property="og:description" content="“MongoDB的标准发行版本中提供了mongo shell。它提供了一种具有对JavaScript语言和标准函数的完全访问权限的JavaScript环境。它为MongoDB数据库提供了一个完整接口。” 在本章中，将学习mongo shell的基础知识以及如何使用它来管理MongoDB文档。在你深入探究创建与数据库交互的应用程序之前，理解MongoDB shell如何工作是很重要的。 没有比上手使"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2021-05-28T07:31:54.000Z"><meta property="article:modified_time" content="2024-04-13T14:27:01.984Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://llz-github.github.io/2021/05/28/%E4%BD%BF%E7%94%A8MongoDB%20Shell--%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%20(2)/"><link rel="prev" title="智能指针shared_ptr" href="https://llz-github.github.io/2021/07/25/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88shared_ptr/"><link rel="next" title="使用MongoDB Shell--进阶介绍" href="https://llz-github.github.io/2021/05/28/%E4%BD%BF%E7%94%A8MongoDB%20Shell--%E8%BF%9B%E9%98%B6%E4%BB%8B%E7%BB%8D/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">53</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本查询"><span class="toc-number">1.</span> <span class="toc-text">基本查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建和插入"><span class="toc-number">1.1.</span> <span class="toc-text">创建和插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#显式创建集合"><span class="toc-number">1.2.</span> <span class="toc-text">显式创建集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用循环插入文档"><span class="toc-number">1.3.</span> <span class="toc-text">使用循环插入文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过显式指定-id进行插入"><span class="toc-number">1.4.</span> <span class="toc-text">通过显式指定_id进行插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新"><span class="toc-number">1.5.</span> <span class="toc-text">更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除"><span class="toc-number">1.6.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取"><span class="toc-number">1.7.</span> <span class="toc-text">读取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查询文档"><span class="toc-number">1.7.1.</span> <span class="toc-text">查询文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择器"><span class="toc-number">1.7.2.</span> <span class="toc-text">选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#投影器"><span class="toc-number">1.7.3.</span> <span class="toc-text">投影器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort（）"><span class="toc-number">1.7.4.</span> <span class="toc-text">sort（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limit（）"><span class="toc-number">1.7.5.</span> <span class="toc-text">limit（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skip（）"><span class="toc-number">1.7.6.</span> <span class="toc-text">skip（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findOne（）"><span class="toc-number">1.7.7.</span> <span class="toc-text">findOne（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用游标"><span class="toc-number">1.7.8.</span> <span class="toc-text">使用游标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain（）"><span class="toc-number">1.7.9.</span> <span class="toc-text">explain（）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用索引"><span class="toc-number">1.8.</span> <span class="toc-text">使用索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单键索引"><span class="toc-number">1.8.1.</span> <span class="toc-text">单键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合索引"><span class="toc-number">1.8.2.</span> <span class="toc-text">复合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对sort操作的支持"><span class="toc-number">1.8.3.</span> <span class="toc-text">对sort操作的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#唯一索引"><span class="toc-number">1.8.4.</span> <span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system-indexes"><span class="toc-number">1.8.5.</span> <span class="toc-text">system.indexes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dropIndex"><span class="toc-number">1.8.6.</span> <span class="toc-text">dropIndex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#relndex"><span class="toc-number">1.8.7.</span> <span class="toc-text">relndex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引如何工作"><span class="toc-number">1.8.8.</span> <span class="toc-text">索引如何工作</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">zl的个人博客</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">使用MongoDB Shell--基本查询 (2)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-05-28 15:31:54"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-05-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2024-04-13 22:27:01"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2024-04-13</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>“MongoDB的标准发行版本中提供了mongo shell。它提供了一种具有对JavaScript语言和标准函数的完全访问权限的JavaScript环境。它为MongoDB数据库提供了一个完整接口。”</p>
<p>在本章中，将学习mongo shell的基础知识以及如何使用它来管理MongoDB文档。在你深入探究创建与数据库交互的应用程序之前，理解MongoDB shell如何工作是很重要的。</p>
<p>没有比上手使用MongoDBshell更好的体验MongoDB数据库的方法了。我们将MongoDB shell介绍分成三个部分，以便读者能够更加容易地领会和实践这些概念。</p>
<p>第一节涵盖了数据库的基础功能，其中包括基本的CRUD操作符。接下来的一节将介绍高级的查询。本章的最后一节会阐释存储和检索数据的两种方式：嵌入和引用。</p>
<h1 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h1><p>本节将简要探讨CRUD操作符（创建、读取、更新和删除）。使用基础示例和练习，将学习这些操作在MongoDB中是如何执行的。另外，将理解查询是如何在MongoDB中执行的。</p>
<p>与用于查询的传统SQL相反，MongoDB使用了其自己的类似于JSON的查询语言来从存储数据中检索信息。</p>
<p>在成功安装MongoDB之后，将导航到目录F:\mongodb\bin\。这个文件夹具有用于运行MongoDB的所有可执行程序。</p>
<p>可以通过执行mongo可执行程序来启动MongoDB shell。<br>第一步总是要启动数据库服务器。打开命令行提示符（以管理员身份运行它）并且运行命令CD\。</p>
<p>接下来，运行命令F:\mongodb\bin\mongod.exe。（如果该安装位于其他某个文件夹，那么这个路径将相应变更。对于本章中的示例来说，安装位于F:\mongodb文件夹）。这样就会启动数据库服务器。</p>
<p>MongoDB会默认侦听本地主机接口的27017端口上所有的入站连接。</p>
<p>数据库服务器已经启动了，那么你就可以开始使用mongo shell将命令发送到该服务器。</p>
<p>在你查看mongo shell之前，我们简要了解如何使用导入/导出工具来将数据导入和导出MongoDB数据库。</p>
<p>首先，创建一个CSV文件来保存具有以下结构的学生记录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525165204.png" alt="image-20210525164556367"></p>
<p>接下来，将数据从MongoDB数据库导入到一个新的集合，以便了解该导入工具如何工作。<br>以管理员身份打开命令行提示符来运行它。以下命令被用于获得关于导入命令的帮助：</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525165200.png" alt="image-20210525164816886"></p>
<p>运行以下命令来将数据从exporteg.csv文件导入到MyDB数据库中一个新的名称为importeg的集合中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport.exe --host localhost --db mydb --collection importeg --type csv --file F:\MongoDB\zufang.csv --headerline</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525165433.png" alt="image-20210525165433073"></p>
<p>第一条是上传失败的返回详情见<a href="https://llz-github.github.io/2021/05/25/mongodb导入csv报错/">mongodb导入csv报错 | zl的个人博客 (llz-github.github.io)</a>，第二条是上传成功的返回。</p>
<p>为了验证该集合是否被创建以及数据是否被导入，要使用mongo shell连接到该数据库（在本示例中是本地主机），并且你要运行命令来验证该集合是否存在。</p>
<p>要启动mongo shell，需要以管理员身份运行命令行提示符并且输入命令F:\MongoDB\bin\mongo.exe（该路径将因安装文件夹而异；在这个示例中，该文件夹是F:\sMongoDB），然后按下Enter键。</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525170426.png" alt="image-20210525170426328"></p>
<p>简要来说，此处你正在做的就是：<br>（1）连接到mongo shell。<br>（2）切换到你的数据库，本示例中是MyDB。<br>（3）使用show collections检查存在于MyDB数据库中的集合。<br>（4）使用导入工具检查你导入的集合数量。<br>（5）最后，执行find(）命令来检查新集合中的数据。</p>
<p>要连接到不同的主机和端口，可以将-host和-port与命令一起使用。默认情况下数据库test被用于上下文环境。在任何时候，执行db命令都会显示当前shell连接的数据库：</p>
<p>为了显示所有的数据库名称，可以运行show dbs命令。执行这个命令将列出用于所连接服务器的所有数据库。</p>
<p>在任何时候，都可以使用help）命令来获得帮助。</p>
<p>如果需要关于db或collection的任何方法的帮助，则可以使用db.help(）或db.&lt;CollectionName&gt;.help(）。</p>
<table>
<thead>
<tr>
<th align="center">RDBMS</th>
<th align="center">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据库</td>
<td align="center">数据库</td>
</tr>
<tr>
<td align="center">表格</td>
<td align="center">集合</td>
</tr>
<tr>
<td align="center">行</td>
<td align="center">文档</td>
</tr>
<tr>
<td align="center">列</td>
<td align="center">字段</td>
</tr>
<tr>
<td align="center">表联合</td>
<td align="center">嵌入文档</td>
</tr>
<tr>
<td align="center">主键</td>
<td align="center">主键 (MongoDB 提供了 key 为 _id )</td>
</tr>
</tbody></table>
<p>我们现在开始探究MongoDB中用于查询的选项。切换到mydb1数据库。</p>
<p>这样就会将上下文切换到mydb1。使用db命令可以确认这一点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525172640.png" alt="image-20210525172640129"></p>
<p>尽管上下文被切换到了mydb1，但如果运行show dbs命令，也不会显示该数据库名称，因为MongoDB只有在将数据插入到数据库时才会创建该数据库。这与MongoDB用于数据助益、动态命名空间分配以及简化和加速的开发过程的动态方式是一致的。如果此时运行show dbs命令，那么将不会在数据库列表中列出mydb1数据库，因为该数据库只有在数据被插入时才会被创建。</p>
<h2 id="创建和插入"><a href="#创建和插入" class="headerlink" title="创建和插入"></a>创建和插入</h2><p>你现在要查看数据库和集合是如何被创建的。正如较早所阐释的，MongoDB中的文档都是JSON格式的。</p>
<p>现在将看到如何创建文档。<br>第一个文档遵循第一个原型，而第二个文档遵循第二个原型。你已经创建了两个名称为userl和user2的文档。</p>
<p>接着你要以下面的操作顺序将这两个文档（userl和user2）添加到users集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user1 &#x3D; &#123;FName:&quot;Test&quot;,LName:&quot;User&quot;,Age:30,Gender:&quot;M&quot;,country:&quot;US&quot;&#125;</span><br><span class="line">user2 &#x3D; &#123;Name:&quot;Test User&quot;,Age:45,Gender:&quot;M&quot;,country:&quot;US&quot;&#125;</span><br><span class="line">db.users.insert(user1)</span><br><span class="line">db.users.insert(user2)</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525173314.png" alt="image-20210525173313914"></p>
<p>上述操作不仅会将这两个文档插入到users集合，还会创建该集合以及数据库。可以使用show collections和show dbs命令来验证这一点。</p>
<p>正如前面所提到过的，show dbs将显示数据库列表。</p>
<p>而show collections将显示当前数据库中的集合列表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525173605.png" alt="image-20210525173605261"></p>
<p>执行命令db.users.find）将显示users集合中的文档。</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525174019.png" alt="image-20210525174018893"></p>
<p>可以看到所创建的两个文档都显示出来了。除了你添加到文档的字段以外，还会为所有文档生成一个附加的_id字段。<br>所有的文档都必须具有一个唯一的_id字段。如果没有显式指定，那么MongoDB同样会自动分配一个作为唯一对象ID，就像上面的示例中所显示的那样。</p>
<hr>
<p>你没有显式插入一个id字段，但当使用find()命令来显示文档时，可以看到一个与每个文档相关联的id字段。<br>其背后的原因在于，默认情况下索引是被创建在该id字段上的。</p>
<hr>
<p>可以使用ensurelndex（）和droplIndex（）命令将索引添加到集合中或者从中移除。在本章后面的内容中我们将介绍这一点。默认情况下，索引会被创建在所有集合的_id字段上。这一默认索引无法被删除。</p>
<h2 id="显式创建集合"><a href="#显式创建集合" class="headerlink" title="显式创建集合"></a>显式创建集合</h2><p>在上面的示例中，第一个插入操作隐式地创建了集合。不过，用户也可以在执行插入语句之前显式创建一个集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection（&quot;users&quot;）</span><br></pre></td></tr></table></figure>

<h2 id="使用循环插入文档"><a href="#使用循环插入文档" class="headerlink" title="使用循环插入文档"></a>使用循环插入文档</h2><p>也可以使用一个for循环来将文档添加到集合。以下代码使用了for来插入用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;1; i &lt;&#x3D; 20; i++) db.users.insert(&#123;&quot;Name&quot;:&quot;Test User&quot; + i, &quot;Age&quot;:10 + i, &quot;Gender&quot;: &quot;F&quot;, &quot;Country&quot;: &quot;India&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525174700.png" alt="image-20210525174700485"></p>
<p>用户出现在集合中。在你继续学习之前，我们要理解“Type“it”for more”语句。</p>
<p>find命令会返回指向结果集的一个游标。相较于一次性在界面上显示所有文档（可能会有数千或数百万个结果），游标会显示前20个文档并且等待请求遍历（it）以便显示其后20个文档，以此类推，直到所有的结果集都被显示出来。</p>
<p>所产生的游标还可以被分配到一个变量，然后可以使用一个while循环编程式地遍历它。该游标对象还可以作为一个数组来操作。</p>
<p>在你的例子中，如果输入“it”并且按下Enter键，就会出现以下信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525174813.png" alt="image-20210525174813305"></p>
<h2 id="通过显式指定-id进行插入"><a href="#通过显式指定-id进行插入" class="headerlink" title="通过显式指定_id进行插入"></a>通过显式指定_id进行插入</h2><p>在前面关于插入的示例中，并没有指定id字段，因此它是被隐式添加的。在以下示例中，将看到如何在一个集合中插入文档时显式指定id字段。<br>在显式指定id字段时，你必须注意该字段的唯一性；否则插入将会失败。<br>以下命令会显式指定id字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.insert(&#123;&quot;_id&quot;:10,&quot;Name&quot;:&quot;explicit id&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525175159.png" alt="image-20210525175159767"></p>
<p>该插入操作会在users集合中创建以下文档：{“id”：10，”Name”：”explicit id”）这一点可以通过运行查询命令来确认。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>在本节中将探究update（）命令，它被用于更新一个集合中的文档。<br>update（）方法默认会更新单个文档。如果需要更新所有符合选择条件的文档，那么可以通过设置multi选项为true来实现这一目的。</p>
<p>我们首先更新已有列的值。$set操作符将被用于更新记录。</p>
<p>以下命令会将所有女性用户的年龄更新为100：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.update(&#123;&quot;gender&quot;:&quot;F&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:100&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>要检查该更新是否完成，可以运行一个find命令来检查所有的女性用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.find(&#123;&quot;gender&quot;:&quot;F&quot;&#125;)</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210525180637.png" alt="image-20210525180637175"></p>
<p>如果检查该输出结果，就会发现只更新了第一个文档记录，这是更新的默认行为，因为没有指定multi选项。现在我们修改该update命令并且加入multi选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.update(&#123;&quot;gender&quot;:&quot;F&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:100&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526084736.png" alt="image-20210526084709696"></p>
<p>如你所见，已经将所有符合条件记录age更新为100。</p>
<p>在处理一个真实的应用程序时，你可能会碰到模式演化的情况，其中你可能最终会将字段添加到文档或者从中移除字段。我们来看看如何在MongoDB数据库中执行这些修改。</p>
<p>update(）操作可被用于文档级别，这有助于更新一个集合中的单个文档或者文档集。</p>
<p>接下来，我们来看看如何将新字段添加到文档。为了将字段添加到文档，需要使用带有$set操作符和multi选项的update()命令。<br>如果用$set使用一个字段名称，而该字段不存在，那么这个字段将会被添加到文档。以下命令会将字段company添加到所有的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.update(&#123;&#125;,&#123;$set:&#123;&quot;company&quot;:&quot;TEstComp&quot;&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526085209.png" alt="image-20210526085209238"></p>
<p>如果对已经存在于文档中的字段执行update（）命令，那么将会更新该字段的值；不过，如果该字段并不存在于文档中，那么该字段将会被添加到文档。</p>
<p>接下来将看到如何使用带有Sunset操作符的相同update（）命令来从文档中移除字段。</p>
<p>以下命令会将字段Company从所有的文档中移除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.update(&#123;&#125;,&#123;$unset:&#123;&quot;company&quot;:&quot;&quot;&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526085409.png" alt="image-20210526085409168"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>要删除一个集合中的文档，可以使用remove（）方法。如果指定一个选择条件，那么只有满足该条件的文档才会被删除。如果没有指定条件，则会删除所有的文档。</p>
<p>以下命令将会删除Gender=‘M’的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.remove(&#123;&quot;gender&quot;:&quot;M&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526085901.png" alt="image-20210526085901011"></p>
<p>不会返回任何文档。</p>
<p>以下命令将删除所有的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526090222.png" alt="image-20210526090222676"></p>
<p>如你所见，不会返回任何文档。</p>
<p>最后，如果希望删除该集合，那么以下命令将会删除这个集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.importeg.drop()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526090344.png" alt="image-20210526090344229"></p>
<p>true为了验证该集合是否被删除，可以运行show collections命令。</p>
<p>如你所见，没有显示集合名称，这样就可以确认该集合已经从数据库中移除了。我们已经介绍了基本的创建、更新和删除操作，下一节将介绍如何执行读取操作。</p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>在本章的这一部分将了解各种示例，这些示例揭示了作为MongoDB的一部分当前可用的查询功能，这些功能使得你能够从数据库中读取所存储的数据。</p>
<p>为了开始使用基本查询，首先创建users集合并且使用insert命令插入数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user1 &#x3D; &#123;FName:&quot;Test&quot;,LName:&quot;User&quot;,Age:30,Gender:&quot;M&quot;,country:&quot;US&quot;&#125;user2 &#x3D; &#123;Name:&quot;Test User&quot;,Age:45,Gender:&quot;F&quot;,country:&quot;US&quot;&#125;db.users.insert(user1)db.users.insert(user2)for(var i &#x3D; 1; i &lt; 20; i++) db.users.insert(&#123;Name:&quot;Test user&quot; + i, &quot;Age&quot;:10 + i, &quot;Gender&quot;:&quot;M&quot;, &quot;country&quot;:&quot;India&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526091606.png" alt="image-20210526091606691"></p>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>MongoDB提供了一个富查询系统。查询文档可以作为参数被传递到find）方法来过滤一个集合中的文档。</p>
<p>一个查询文档是在前“{”和后“}”一对大括号中指定的。一个查询文档是在返回结果集之前针对集合中的所有文档来匹配的。<br>使用不带有任何查询文档的find（）命令或者带有一个空查询文档的像find（{}）这样的命令会返回集合中所有的文档。</p>
<p>一个查询文档可以包含选择器和投影器。</p>
<blockquote>
<p>选择器就像SQL中的where条件或者一个用于过滤出结果的过滤器。</p>
<p>投影器就像选择条件或者用于显示数据字段的选择列表。</p>
</blockquote>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>你现在将看到如何使用选择器。以下命令将返回所有的女性用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526114822.png" alt="image-20210526114821946"></p>
<p>MongoDB还支持将不同条件合并到一起的操作符以便根据你的需求来改进你的搜索。</p>
<p>现在我们将上面的查询修改为查询来自印度的女性用户。以下命令将返回相同结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;,$or:[&#123;&quot;country&quot;:&quot;India&quot;&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526115156.png" alt="image-20210526115156809"></p>
<p>接下来，如果希望找出所有来自印度或美国的女性用户，则可以执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;,$or:[&#123;&quot;country&quot;:&quot;India&quot;&#125;,&#123;&quot;country&quot;:&quot;US&quot;&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526120621.png" alt="image-20210526120621365"></p>
<p>出于聚合的需要，则需要使用聚合函数。接着，将学习如何将count(）函数用于聚合。</p>
<p>在上面的示例中，相较于显示文档，你希望计算出生活在印度或美国的女性用户数。因此要执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;,$or:[&#123;&quot;country&quot;:&quot;India&quot;&#125;,&#123;&quot;country&quot;:&quot;US&quot;&#125;]&#125;).count()</span><br></pre></td></tr></table></figure>

<h3 id="投影器"><a href="#投影器" class="headerlink" title="投影器"></a>投影器</h3><p>你已经看到了如何使用选择器来过滤出集合中的文档。在上面的示例中，find0命令会返回匹配该选择器的文档的所有字段。<br>我们来将一个投影器添加到该查询文档，其中，除了该选择器之外，你还将涉及需要被显示的具体细节或者字段。</p>
<p>假定你希望显示所有女性员工的名字和年龄。在这种情况下，就还需要将一个投影器与该选择器一起使用。</p>
<p>执行以下命令以返回期望的结果集：(0不显示，1显示)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;&#125;,&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526121351.png" alt="image-20210526121351588"></p>
<h3 id="sort（）"><a href="#sort（）" class="headerlink" title="sort（）"></a>sort（）</h3><p>在MongoDB中，排列顺序是按如下来指定的：1用于升序排列，而-1用于降序排列。</p>
<p>如果在上面的示例中，你希望按照年龄降序排列记录，那么你就要执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;&#125;,&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;).sort(&#123;&quot;Age&quot;:-1&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526135125.png" alt="image-20210526135124948"></p>
<h3 id="limit（）"><a href="#limit（）" class="headerlink" title="limit（）"></a>limit（）</h3><p>你现在将了解如何才能限制你的结果集中的记录。例如，在具有数千个文档的大型集合中，如果仅希望返回5个匹配的文档，则可以使用limit命令，它完全可以让你完成该任务。</p>
<p>回到之前对生活在印度或美国的女性用户的查询，假如你希望限制该结果集并且只返回两个用户，则需要执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;,$or:[&#123;&quot;country&quot;:&quot;India&quot;&#125;,&#123;&quot;country&quot;:&quot;US&quot;&#125;]&#125;).limit(2)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526135332.png" alt="image-20210526135332133"></p>
<h3 id="skip（）"><a href="#skip（）" class="headerlink" title="skip（）"></a>skip（）</h3><p>如果需求是跳过前两个记录并且返回第3和第4个用户，则可以使用skip命令。需要执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Gender&quot;:&quot;M&quot;,$or:[&#123;&quot;country&quot;:&quot;India&quot;&#125;,&#123;&quot;country&quot;:&quot;US&quot;&#125;]&#125;).limit(2).skip(2)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526135524.png" alt="image-20210526135524208"></p>
<h3 id="findOne（）"><a href="#findOne（）" class="headerlink" title="findOne（）"></a>findOne（）</h3><p>findOne(）命令类似于find()命令。findOne(）方法可以使用与find()一样的参数，但不同于返回一个游标，它会返回单个文档。假设你希望返回一个要么生活在印度要么生活在美国的女性用户，可以使用以下命令来实现此目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.findOne(&#123;&quot;Gender&quot;:&quot;M&quot;&#125;,&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526140038.png" alt="image-20210526140038300"></p>
<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><p>在使用了find()方法时，MongoDB会将查询结果作为一个游标对象来返回。为了显示该结果，mongo shell会遍历所返回的游标。</p>
<p>MongoDB使得用户可以使用find方法的游标对象。在接下来的示例中，将看到如何将游标对象存储到一个变量中并且使用while循环来操作它。</p>
<p>假设你希望返回在美国的所有用户。为了实现该目标，你创建了一个变量，将find()的输出结果指派给了这个变量，该结果是一个游标，然后使用while循环遍历和打印该输出结果。</p>
<p>这段代码看起来应该如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var c &#x3D; db.users.find(&quot;country&quot;:&quot;US&quot;)while(c.hasNext()) printjson(c.next())</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526140728.png" alt="image-20210526140727987"></p>
<p>next()函数会返回下一个文档。hasNext()函数会在一个文档存在时返回true，而printjson(）会以JSON格式呈现该输出结果。</p>
<p>被分配给游标对象的变量还可以作为数组来操作。如果，相较于循环遍历该变量，你希望显示位于数组索引1的文档，则可以运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var c &#x3D; db.users.find(&#123;&quot;country&quot;:&quot;US&quot;&#125;)printjson(c[1])</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526141252.png" alt="image-20210526141252195"></p>
<h3 id="explain（）"><a href="#explain（）" class="headerlink" title="explain（）"></a>explain（）</h3><p>explain（）函数可用于查看在执行一个查询时MongoDB数据库当前运行的步骤。从版本3.0开始，该函数的输出格式以及传递给该函数的参数已经发生了变化。它使用了一个可选的被称为verbose的参数，它会判定explain输出看起来应该是什么样。这些是详细级别的模式：allPlansExecution、executionStats 以及queryPlanner。默认的详细级别模式是queryPlanner，这意味着如果不做指定，则将默认为queryPlanner。<br>以下代码涵盖了过滤username字段时执行的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;&quot;Name&quot;:&quot;Test User&quot;&#125;).explain(&quot;allPlansExecution&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210526142211.png" alt="image-20210526142211742"></p>
<p>如你所见，explain(）输出结果会返回关于queryPlanner、executionStats和serverlnfo的信息。正如上面代码显示的，该输出所返回的信息取决于所选择详细程度的模式。</p>
<p>你已经看到了如何执行基本查询、排序、限制等。你还看到了如何使用while循环操作结果集或者将结果集作为数组来操作。在下一节中，将了解索引以及如何才能在你的查询中使用它们。</p>
<h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p>索引被用于为频繁使用的查询提供高性能读取操作。默认情况下，当一个集合被创建并且文档被添加到其中时，就会在该文档的_id字段上创建一个索引。</p>
<p>在本节中，将了解如何创建不同类型的索引。我们首先使用for循环在一个名称为testindx的新集合中插入1百万个文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;0; i &lt;&#x3D; 1000000; i++) &#123;db.testIndex.insert(&#123;&quot;Name&quot;:&quot;user&quot; + i, &quot;Age&quot;:Math.floor(Math.random() * 120)&#125;)&#125;</span><br></pre></td></tr></table></figure>

<p>接着，运行find()命令抓取值为user101的一个Name。运行explain（）命令检查MongoDB正在执行哪些步骤以便返回结果集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.find(&#123;&quot;Name&quot;:&quot;user101&quot;&#125;).explain(&quot;allPlansExecution&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527133754.png" alt="image-20210527133745887"></p>
<p>如你所见，数据库扫描了整个表。这会造成严重的性能影响并且是由于没有使用索引造成的。</p>
<h3 id="单键索引"><a href="#单键索引" class="headerlink" title="单键索引"></a>单键索引</h3><p>我们在该文档的Name字段上创建一个索引。使用ensurelndex()来创建这个索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.ensureIndex(&#123;&quot;Name&quot;:1&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527134535.png" alt="image-20210527134535132"></p>
<p>索引的创建需要几分钟的时间，这取决于服务器以及集合的大小。<br>我们来运行与你之前使用explainO运行的相同的查询，以检查在索引创建之后数据库会执行哪些步骤。检查输出结果中的n、nscanned和millis字段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527134725.png" alt="image-20210527134725435"></p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527135009.png" alt="image-20210527135008842"></p>
<p>正如可以在该结果中所看到的，没有进行表扫描。索引的创建会在查询执行时间方面产生显著的差异。</p>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>在创建一个索引时，你应该牢记，索引要覆盖你大多数的查询。如果有时仅查询Name字段并且有时同时查询Name和Age字段，那么在Name和Age字段上创建一个复合索引将会比在单一字段上创建索引更有益处，因为复合索引将覆盖这两种查询。</p>
<p>以下命令会在testindx集合的Name和Age字段上创建一个复合索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testindex1.ensureIndex(&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527135502.png" alt="image-20210527135502402"></p>
<p>复合索引有助于MongoDB更有效地执行带有多个子句的查询。在创建一个复合索引时，还有一点非常重要，这就是要牢记字段将被用于第一个出现的精确匹配（比如Name:”S1”），其后是要用在范围中的字段（比如Age:{“$gt”：20}）。</p>
<p>因此，上面的索引对于以下查询将很有帮助：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testindex1.find(&#123;&quot;Name&quot;:&quot;user5&quot;,&quot;Age&quot;:&#123;&quot;$gt&quot;:25&#125;&#125;).explain(&quot;allPlansExecution&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527140021.png" alt="image-20210527140021819"></p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527140037.png" alt="image-20210527140037756"></p>
<h3 id="对sort操作的支持"><a href="#对sort操作的支持" class="headerlink" title="对sort操作的支持"></a>对sort操作的支持</h3><p>在MongoDB中，使用一个索引字段来对文档排序的sort操作会提供最佳的性能。</p>
<p>就像在其他数据库中一样，由于这一点，MongoDB中的索引具有一个顺序。如果一个索引被用于访问文档，那么它将按照与索引相同的顺序来返回结果。</p>
<p>复合索引需要在对多个字段进行排序时创建。在一个复合索引中，输出结果可以按照索引前缀的顺序或者完整索引的顺序来排序。</p>
<p>索引前缀是复合索引的一个子集，它包含索引开头部分的一个或多个字段。</p>
<p>例如，{x：1，y：1，z：1}就是复合索引的索引前缀。</p>
<p>sort操作可以基于索引前缀的任意组合，比如{x：1}，{x：1，y：1}。</p>
<p>如果一个复合索引是排序的一个前缀，那么它就仅能有助于排序。</p>
<p>例如，一个基于Age、Name和Class的复合索引，类似于</p>
<blockquote>
<p>db.testindx.ensureIndex（{“Age”：1，”Name”：1，”Class”：1}）</p>
</blockquote>
<p>那么，它对于以下查询就是有用的：</p>
<blockquote>
<p>db.testindx.find().sort({“Age”:1})</p>
<p>db.testindx.find().sort({“Age”:1,”Name”:1})</p>
<p>db.testindx.find().sort({“Age”:1,”Name”:1,”Class”:1)}</p>
</blockquote>
<p>上面的索引在以下查询中没什么用处：</p>
<blockquote>
<p>db.testindx.find().sort({“Gender”:1,”Age”:1,”Name”:1}）</p>
</blockquote>
<p>可以通过使用explain()命令来诊断MongoDB是如何处理一个查询的。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>在一个字段上创建索引并不会确保唯一性，因此，如果一个索引是基于Name字段创建的，那么两个或多个文档就可以具有相同的名称。不过，如果唯一性是需要被启用的其中一个约束，那么在创建该索引时，这个唯一属性就需要被设置为true。</p>
<p>首先，我们删除已有的索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.dropIndexes()</span><br></pre></td></tr></table></figure>

<p>以下命令将在testindx集合的Name字段上创建一个唯一索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.ensureIndex(&#123;&quot;Name&quot;:1&#125;,&#123;&quot;unique&quot;:true&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527145113.png" alt="image-20210527145113624"></p>
<p>现在，如果像下面所示的那样尝试在该集合中插入重复的名称，那么MongoDB就会返回一个错误，并且不允许重复记录的插入：</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527145328.png" alt="image-20210527145328604"></p>
<p>如果检查该集合，就会看到只保存了第一个。</p>
<p>也可以为复合索引启用唯一性，这意味着尽管单个字段可以具有重复值，但其组合将一直是唯一的。</p>
<p>例如，如果有一个{“name”：1，“age”：1}的索引，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.ensureIndex(&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;,&#123;&quot;unique&quot;:true&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527145609.png" alt="image-20210527145609053"></p>
<p>那么以下插入将是允许的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.insert(&#123;&quot;Name&quot;:&quot;userName002&quot;&#125;)db.testIndex1.insert(&#123;&quot;Name&quot;:&quot;userName002&quot;,&quot;Age&quot;:2&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527150125.png" alt="image-20210527150125239"></p>
<p>不过，如果执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.insert(&#123;&quot;Name&quot;:&quot;userName002&quot;,&quot;Age&quot;:2&#125;)</span><br></pre></td></tr></table></figure>

<p>它将抛出一个错误，如以下代码所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527150146.png" alt="image-20210527150146356"></p>
<p>可以先创建集合并且插入文档，然后在该集合上创建一个索引。如果在该集合上创建一个唯一索引，而创建索引的字段可能存在重复值的话，那么索引的创建将会失败。</p>
<p><del>为了满足这一场景，MongoDB提供了一个dropDups选项。这个dropDups选项会保留找到的第一个文档并且移除具有重复值的所有后续文档。</del></p>
<p><u><strong>此函数在3.0后已废弃</strong></u></p>
<p><del>以下命令将在name字段上创建一个唯一索引，并且将删除所有重复的文档：</del></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.ensureIndex(&#123;&quot;Name&quot;:1&#125;,&#123;&quot;unique&quot;:true,&quot;dropDups&quot;:true&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="system-indexes"><a href="#system-indexes" class="headerlink" title="system.indexes"></a>system.indexes</h3><p>无论你何时创建一个数据库，默认情况下都会创建一个system.indexes集合。关于数据索引的所有信息都存储在system.indexes集合中。这是一个保留集合，因此你无法修改其文档或者从中移除文档。你只能通过ensurelndex和dropIndexes数据库命令来操作它。</p>
<p>无论何时创建了一个索引，都可以在system.indexes中看到其元信息。以下命令可用于提取所有关于示例集合的索引信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collectionName.getIndexes()</span><br></pre></td></tr></table></figure>

<p>例如，以下命令将返回所有在testindx集合上创建的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.getIndexes()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527151407.png" alt="image-20210527151407378"></p>
<h3 id="dropIndex"><a href="#dropIndex" class="headerlink" title="dropIndex"></a>dropIndex</h3><p>dropIndex命令被用于移除索引。</p>
<p>以下命令将从testindx集合中移除Name字段索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.testIndex1.dropIndexes(&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/llz-github/image/img1/20210527151342.png" alt="image-20210527151342344"></p>
<h3 id="relndex"><a href="#relndex" class="headerlink" title="relndex"></a>relndex</h3><p>当已经在集合上执行了若干插入和删除时，你可能必须重构索引，以便可以用最佳的方式使用索引。relndex命令被用于重构索引。<br>以下命令会重构一个集合的所有索引。它首先会删除索引，其中包括_id字段上的默认索引，然后它会重构这些索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collectionname.reIndex()</span><br></pre></td></tr></table></figure>

<p>我们将在下一章详尽探讨MongoDB中可用的不同类型的索引。</p>
<h3 id="索引如何工作"><a href="#索引如何工作" class="headerlink" title="索引如何工作"></a>索引如何工作</h3><p>MongoDB会在一个二叉树（BTree）结构中存储索引，因此它自动支持范围查询。</p>
<p>如果一个查询中使用了多个选择条件，那么MongoDB就会尝试找到最佳的单个索引来选择一个候选集。在那之后，它会依次遍历该集合来估算其他条件。</p>
<p>在首次执行该查询时，MongoDB会为每一个可用于该查询的索引创建多个执行计划。它会让这些计划在一定的时间间隔中轮流执行，直到执行最快的计划完成。然后其结果会被返回到系统，该结果会记住最快执行计划使用的索引。</p>
<p>对于后续查询，将会使用此被记住的索引，直到该集合中发生了一定数量的更新。在超过更新限制时，系统将再次执行该处理过程以找出此时适用的最佳索引。</p>
<p>当发生以下任意事件时，就会再次对查询计划进行评估：</p>
<ul>
<li>集合接收到1000个写操作。</li>
<li>添加或删除了一个索引。</li>
<li>mongod程序重启了。</li>
<li>发生了用于重构索引的再次索引。</li>
</ul>
<hr>
<p>如果希望重写MongoDB的默认索引选择，那么可以使用hint()方法达成目的。</p>
<p>在版本2.6中引入了索引过滤器。它是由优化器将为一个查询所评估的索引组成的，评估对象包括查询、投影和排序。MongoDB将使用由索引过滤器提供的索引并将忽略hin()。</p>
<hr>
<p>在版本2.6之前，MongoDB一直都仅使用一个索引，因此你需要确保组合索引的存在，以更好匹配你的查询。这可以通过检查查询的排序以及搜索条件来完成。</p>
<p>索引交集是在版本2.6中引入的。它使得用于满足具有复合条件的查询的索引交集成为可能，其中一部分条件由一个索引满足，而其他部分则由其他索引来满足。</p>
<p>一般来说，索引交集是由两个索引组成的；不过，也可以将多个索引交集用于解决一个查询。此功能提供了更好的优化。</p>
<p>就像在其他数据库中一样，索引的维护总是伴随着附加成本。变更集合的每一个操作（比如创建、更新或删除）都会带来开销，因为索引也需要被更新。为了维持一个最佳平衡，你需要定期检查使用一个索引的有效性，这可以通过你在系统上执行的读和写的比例来衡量。识别出较少使用的索引并且删除它们。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lilongzhe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://llz-github.github.io/2021/05/28/%E4%BD%BF%E7%94%A8MongoDB%20Shell--%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%20(2)/">https://llz-github.github.io/2021/05/28/%E4%BD%BF%E7%94%A8MongoDB%20Shell--%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%20(2)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://llz-github.github.io" target="_blank">zl的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/07/25/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88shared_ptr/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">智能指针shared_ptr</div></div></a></div><div class="next-post pull_right"><a href="/2021/05/28/%E4%BD%BF%E7%94%A8MongoDB%20Shell--%E8%BF%9B%E9%98%B6%E4%BB%8B%E7%BB%8D/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用MongoDB Shell--进阶介绍</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By lilongzhe</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>